```markdown
# Code Generation Rules for DTOs

## 1. Purpose
All Data Transfer Objects (DTOs) must use static factory methods as the primary construction mechanism, ensuring immutability and maintaining compatibility with JSON serialization/deserialization. These rules are designed to enhance code readability, maintainability, consistency, and domain intent clarity.

## 2. Rule Details
All DTO classes must adhere to the following guidelines:

### Package and Structure:
*   DTOs should be located in a designated `[your_application_context].dto` package (e.g., `com.example.app.dto`).
*   Class names must clearly reflect the domain and purpose, using the `Dto` suffix (e.g., `CreateItemResponseDto`, `SearchQueryRequestDto`).

### Immutability Assurance:
*   DTOs must be **immutable**, and should not include the `@Setter` annotation or setter methods.

### Use of Static Factory Methods:
*   DTO creation must primarily use static factory methods.
*   Method names should clearly express the domain scenario:
    *   Response DTOs: `success` (for success scenarios), `failure` (for failure scenarios).
    *   Request DTOs: `of` (for general-purpose creation).
*   Methods should only accept required fields or provide default values to prevent caller errors.
*   Example:
```java
public static SomeResponseDto success(String message, Long entityId, int count) {
    return new SomeResponseDto(message, entityId, count, true);
}
public static SomeResponseDto failure(String message) {
    return new SomeResponseDto(message, null, 0, false);
}
```

### Lombok Annotations:
*   `@Getter`: Provides getters for all fields.
*   `@AllArgsConstructor`: Provides a constructor including all fields (used internally by static factory methods).
*   `@NoArgsConstructor`: Provides an empty constructor for JSON deserialization compatibility (e.g., Jackson).
*   `@Setter` forbidden: To ensure immutability.
*   `@Builder` forbidden: Static factory methods provide clearer intent, so builders are not used (may be allowed exceptionally, see below).

### JSON Serialization/Deserialization Compatibility:
*   Include `@NoArgsConstructor` for compatibility with serialization libraries like Jackson/Gson.
*   `@JsonProperty`, `@JsonInclude` annotations can be used if necessary.
*   Example:
```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class SomeResponseDto {
    private final String message;
    // ...
}
```

### Field Definition:
*   Fields must reflect domain requirements and use clear names (e.g., `itemId`, `quantity`).
*   Required fields must be ensured to be initialized with non-null values by static factory methods.
*   Optional fields should be handled with `null` or default values (e.g., `0`, `false`).

### Domain-Specific Method Naming Conventions:
*   Response DTOs: `success` for successful responses, `failure` for failed responses. Additional scenarios (e.g., `partialSuccess`) defined per domain.
*   Request DTOs: `of` for general creation; if specific scenarios exist, name them accordingly (e.g., `fromExternalData`).
*   Example:
```java
public static SomeRequestDto of(String identifier, String value, String type) {
    return new SomeRequestDto(identifier, value, type);
}
```

### Exceptional Use Cases:
*   **Complex DTOs**: If a DTO has many fields (10+) or many optional fields, `@Builder` may be selectively allowed. However, builder method names should be scenario-specific, not just `builder` (e.g., `successBuilder`, `failureBuilder`).
*   **Record Consideration**: In Java 14+ environments, `record` can be considered as an alternative. However, if JSON customization is complex, maintain class-based DTOs.
*   Example:
```java
public record SomeResponseDto(String message, Long entityId, int count, boolean success) {
    public static SomeResponseDto success(String message, Long entityId, int count) {
        return new SomeResponseDto(message, entityId, count, true);
    }
}
```

### Maintainability and Testing:
*   All DTOs must follow the same pattern (static factory methods + immutability) to ensure consistency.
*   Simplify object creation during testing by using static factory methods.
*   Example: `assertEquals(SomeResponseDto.success("Success", 1L, 2), response);`

### Logging and Documentation:
*   Logging during DTO creation is unnecessary, but call scenarios should be clearly explained with comments or documentation.
*   Example:
```java
/**
 * Creates a success response DTO.
 * @param message The success message.
 * @param entityId The ID of the processed entity.
 * @param count The number of processed items.
 * @return A DTO representing a success state.
 */
public static SomeResponseDto success(String message, Long entityId, int count) {
    return new SomeResponseDto(message, entityId, count, true);
}
```

## 3. Example DTO Code
All DTOs generated by AI must follow the format below:
```java
package com.example.app.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

/**
 * DTO for processing response.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SomeResponseDto {
    private final String message;
    private final Long entityId;
    private final int processedCount;
    private final boolean success;

    /**
     * Creates a success response DTO.
     * @param message The success message.
     * @param entityId The ID of the processed entity.
     * @param processedCount The number of processed items.
     * @return A DTO representing a success state.
     */
    public static SomeResponseDto success(String message, Long entityId, int processedCount) {
        return new SomeResponseDto(message, entityId, processedCount, true);
    }

    /**
     * Creates a failure response DTO.
     * @param message The failure message.
     * @return A DTO representing a failure state.
     */
    public static SomeResponseDto failure(String message) {
        return new SomeResponseDto(message, null, 0, false);
    }
}
```

## 4. Application Guidelines

### Response DTOs:
*   Always provide `success` and `failure` methods.
*   `success` should accept all required fields and set `success=true`.
*   `failure` should only accept an error message, with other fields using default values (`null`, `0`, `false`).

### Request DTOs:
*   Provide an `of` method for general-purpose creation.
*   Add scenario-specific methods (e.g., `fromExternalData`) if required by the domain.

### JSON Compatibility:
*   `@NoArgsConstructor` is mandatory, `@JsonInclude(JsonInclude.Include.NON_NULL)` is recommended.

### Exceptional Cases:
*   If a DTO has 10 or more fields or many optional fields, `@Builder` can be additionally provided, but the builder's name should be scenario-specific (e.g., `successBuilder`).
*   Consider using `record` if JSON customization is simple.

## 5. Ensuring Maintainability

*   **Consistency**: All DTOs follow the same pattern (static factory methods + immutability) to improve code predictability.
*   **Readability**: Method names like `success`, `failure` clarify domain intent.
*   **Error Prevention**: Immutability and static methods prevent the creation of invalid states.
*   **Testability**: Static methods simplify test data generation.
*   **Team Collaboration**: Document rules in team documentation and verify adherence during code reviews.

## 6. Constraints

*   `@Setter` usage is forbidden.
*   `@Builder` is only for exceptional situations (complex DTOs).
*   Hardcoded initial values (e.g., `success=true`) are handled within static methods.
*   DTOs must not contain domain logic (e.g., business logic, calculations).

## 7. AI Code Generation Guidelines
When AI generates DTO code:

*   Strictly adhere to the above rules.
*   Create DTOs in the designated `[your_application_context].dto` package.
*   Class names should reflect the domain and purpose (e.g., `XxxRequestDto`, `XxxResponseDto`).
*   Must include static factory methods (`success`, `failure`, `of`).
*   Use `@Getter`, `@AllArgsConstructor`, `@NoArgsConstructor`, and exclude `@Setter`.
*   Provide comments explaining method purpose and parameters.
*   Wrap the code with an `<xaiArtifact>` tag, with a unique `artifact_id`, `title` as the class name, and `contentType="text/x-java-source"`.

## 8. Exception Handling

*   If a new DTO requires a scenario different from existing patterns, discuss with the team and modify the rules.
*   Example: If a specific DTO requires complex creation logic, consider a separate factory class.
```