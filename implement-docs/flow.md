## 유저 플로우: 코드 분석 기능

### 유저 플로우 1: 사용자가 코드를 성공적으로 분석하는 경우 (수정본)

**1. 입력**
*   사용자가 'RegisterProblemModal' 내 에디터에 분석할 소스 코드를 작성합니다.
*   사용자가 해당 소스 코드의 프로그래밍 언어를 선택합니다.
*   사용자가 '분석 시작하기' 버튼을 클릭합니다.

**2. 처리**
*   **[Frontend]** 클라이언트는 코드 에디터에 내용이 존재하는지 확인합니다.
*   **[Frontend]** 로딩 상태를 표시하고, 작성된 코드와 선택된 언어를 담아 백엔드에 API 요청을 전송합니다.
*   **[Backend]** 서버는 요청을 받아 `ProblemService.java` 파일을 참조하여 코드와 언어 데이터를 Redis에 해시(Hash) 형태로 저장합니다.
*   **[Backend]** `LogicAnalyzeRequestDto`를 다음과 같이 구성합니다.
    *   `description`: 현재 문제의 설명
    *   `input`: 문제의 입력 조건 및 예시
    *   `output`: 문제의 출력 조건 및 예시
    *   `code`: 사용자가 제출한 소스 코드
*   **[Backend]** 구성된 DTO를 인자로 `GeminiClient.getCoreLogics` 메서드를 호출하여 외부 AI 모델로부터 코드 분석 결과를 요청합니다.
*   **[Backend]** AI 모델로부터 성공적으로 분석 결과를 수신합니다.
*   **[Backend]** 수신된 분석 결과를 DTO로 변환하고, `ProblemService.java` 파일을 참조하여 해당 데이터를 Redis에 해시(Hash) 형태로 저장합니다.
*   **[Backend]** 클라이언트에게 분석 결과 데이터가 포함된 성공 응답(200 OK)을 반환합니다.
*   **[Frontend]** 성공 응답을 수신하고 로딩 상태를 종료합니다.
*   **[Frontend]** 응답 데이터를 URL 파라미터로 사용할 수 있는 형태로 변환(직렬화)합니다.
*   **[Frontend]** 변환된 데이터를 포함하여 `/algorithm-logic-flow-analysis` 경로로 페이지를 이동시킵니다.
*   **[Frontend]** `/algorithm-logic-flow-analysis` 페이지의 컴포넌트는 URL의 파라미터를 읽어옵니다.
*   **[Frontend]** 읽어온 데이터를 파싱(역직렬화)하여 사용 가능한 객체 형태로 변환합니다.
*   **[Frontend]** 변환된 데이터를 분석 결과를 표시하는 하위 컴포넌트들의 props로 전달하여 화면에 삽입합니다.

**3. 출력**
*   사용자는 URL의 데이터를 기반으로 분석 결과가 화면에 채워지고 렌더링된 페이지를 보게 됩니다.
*   **Side Effect:** 사용자의 코드와 AI의 분석 결과가 각각 Redis에 저장됩니다.

### 유저 플로우 2: 사용자가 코드를 입력하지 않고 분석을 시도하는 경우 (Edge Case)

**1. 입력**
*   사용자가 'RegisterProblemModal' 내 에디터에 코드를 작성하지 않은 상태입니다.
*   사용자가 '분석 시작하기' 버튼을 클릭합니다.

**2. 처리**
*   **[Frontend]** 클라이언트는 코드 에디터에 내용이 존재하는지 확인합니다.
*   **[Frontend]** 내용이 없으므로 유효성 검증에 실패합니다.
*   **[Frontend]** 백엔드로 API 요청을 보내는 로직을 중단합니다.
*   **[Frontend]** 에러 메시지를 표시하기 위해 `apiError` 상태 변수에 관련 정보를 할당합니다.

**3. 출력**
*   사용자에게 코드 입력이 필요하다는 피드백(오류 메시지)이 UI에 표시됩니다.
*   사용자는 'RegisterProblemModal'에 그대로 머물게 됩니다.
*   **Side Effect:** 백엔드로의 네트워크 요청이 발생하지 않습니다.

### 유저 플로우 3: 코드 분석 API 요청이 실패하는 경우 (Edge Case)

**1. 입력**
*   사용자가 'RegisterProblemModal' 내 에디터에 코드를 올바르게 작성합니다.
*   사용자가 '분석 시작하기' 버튼을 클릭합니다.

**2. 처리**
*   **[Frontend]** 클라이언트는 코드 에디터에 내용이 존재하는 것을 확인하고, 로딩 상태를 표시하며 백엔드에 API 요청을 전송합니다.
*   **[Backend]** 서버는 요청을 처리하는 과정에서 예기치 않은 문제(예: 외부 AI 서비스 호출 실패, Redis 연결 오류, 내부 로직 예외 등)가 발생합니다.
*   **[Backend]** 서버는 오류를 감지하고 클라이언트에게 실패 응답(예: 500 Internal Server Error)을 반환합니다.
*   **[Frontend]** 클라이언트는 서버로부터 실패 응답을 수신합니다.
*   **[Frontend]** 로딩 상태를 종료하고, 에러 메시지를 표시하기 위해 `apiError` 상태 변수에 관련 정보를 할당합니다.

**3. 출력**
*   사용자에게 일시적인 오류가 발생했음을 알리는 피드백(오류 메시지)이 UI에 표시됩니다.
*   사용자는 'RegisterProblemModal'에 그대로 머물게 됩니다.
*   페이지 이동이 발생하지 않습니다.