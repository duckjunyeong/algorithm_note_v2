{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 기획서(PRD)\n\n## 1. 제품명\nAlgoRevise (가칭) – AI 기반 알고리즘 오답 관리 플랫폼\n\n## 2. 제품 개요\nAlgoRevise는 사용자가 풀었던 알고리즘 문제를 등록하면, AI가 풀이 논리 흐름을 자동 분석·시각화하고, 사용자가 막힌 로직을 선택하면 AI 챗봇이 해당 약점을 심층 진단한 뒤 맞춤형 테스트 문제를 출제·평가해 주는 웹앱입니다. 반복 복습과 동기 부여 기능으로 코딩 테스트 합격 가능성을 높여 줍니다.\n\n## 3. 목표\n1. 첫 3개월 내 MAU 1,000명 달성\n2. 오답 재출제 후 정답률 20%p 이상 향상\n3. 프리미엄 전환율 5% 이상\n\n## 4. 타깃 사용자\n알고리즘 문제를 집중적으로 학습하며 코딩 테스트를 준비하는 대학생·취준생(20~29세, 개발 직군 지망)\n\n## 5. 문제 진술(Pain Point)\n반복적으로 틀린 문제를 체계적으로 관리하지 못해, 같은 유형에서 계속 틀리고 학습 효율이 떨어진다.\n\n## 6. 가치 제안(Value Proposition)\n“AI가 약점을 찾아 주고, 맞춤 문제로 다시 훈련해 코딩 테스트 합격선을 확실히 넘게 한다.”\n\n## 7. 주요 기능\n### 7.1 핵심 기능\n1. 문제 등록 & 풀이 흐름 자동 분석/시각화\n2. 약점 구간 선택 → AI 챗봇 심층 분석 & 맞춤 테스트 문제 자동 출제\n\n### 7.2 보조 기능\nA. 막힌 로직 시각화 다이어그램\nC. 학습 통계 대시보드\nF. 레벨·뱃지 시스템\n\n## 8. 사용자 스토리\n1. 학생 김코딩은 백준 문제를 풀다 틀린 코드를 플랫폼에 업로드한다.\n2. AI가 김코딩의 코드 흐름을 그래프로 보여주고, 논리 오류가 의심되는 단계에 강조 표시를 한다.\n3. 김코딩이 막힌 단계(예: DP 전이식 설정)를 클릭한다.\n4. AI 챗봇이 해당 단계의 개념과 일반 실수 패턴을 설명하고, 비슷한 난이도의 맞춤 문제를 출제한다.\n5. 김코딩이 테스트 문제를 풀고 채점 결과를 확인한다.\n6. 정답 시 오답노트는 “완료” 상태가 되며, 설정한 복습 주기(예: 7일) 후 “백로그”로 돌아와 재도전 알림을 받는다.\n\n## 9. MVP 범위\n필수:\n- 문제 등록(코드/링크 업로드) & AI 분석\n- 약점 선택 UI + 챗봇 심층 분석\n- 맞춤 문제 자동 출제 및 채점\n- 기본 통계(총 문제 수, 완수 비율)\n\n제외(향후):\n- 커뮤니티 공유, 다중 사용자 실시간 협업, 모바일 네이티브 앱\n\n## 10. 성공 지표(KPI)\n- DAU/MAU 비율 ≥ 25%\n- 첫 맞춤 문제 정답률 ≥ 60%\n- 복습 완료율 ≥ 40%\n- 평균 세션 길이 ≥ 8분\n\n## 11. 비즈니스 모델\nFreemium\n- 무료: 핵심 기능(문제 등록, AI 분석, 맞춤 문제 1회/일)\n- 프리미엄(₩7,900/월): 무제한 맞춤 문제, 고급 통계, 레벨·뱃지, 복습 캘린더 연동\n\n## 12. 로드맵\n| 분기 | 목표 |\n|------|------|\n| Q1  | MVP 개발·내부 베타  |\n| Q2  | 대학 동아리 워크숍→퍼블릭 런칭, 프리미엄 결제 도입 |\n| Q3  | 통계 대시보드·레벨 시스템, 모바일 반응형 개선 |\n| Q4  | 커뮤니티 기능 실험, 해외 알고리즘 사이트 연동 |\n\n## 13. 이해관계자 & 역할\n- Product Owner(캡틴): 요구사항 우선순위 결정\n- PM(Vooster): 기획·프로세스 관리\n- AI 엔지니어: 모델 프롬프트·맞춤 문제 생성 로직\n- 프론트엔드: React SPA 개발\n- 백엔드: API, 데이터베이스, 챗봇 서비스 연동\n\n## 14. 가정 및 리스크\n- AI 분석 정확도가 80% 이상이어야 사용자 신뢰 확보(모델 튜닝 필요)\n- 맞춤 문제 출제가 저작권 문제를 일으키지 않도록 자체 생성 문제 사용\n- 대학생 대상 워크숍 확보 실패 시 초기 유입 지연 가능 → 온라인 커뮤니티 전략 준비\n\n## 15. 성공 조건\n- AI가 약점을 ‘눈에 보이게’ 설명하여 페인포인트를 즉시 해결\n- 반복 학습 루프 완결(등록→분석→테스트→복습) UX가 5분 이내로 끝남\n\n---\n캡틴이 수정·추가하고 싶은 부분이 있으면 언제든 말씀해 주세요!",
      "writedAt": "2025-09-13T01:31:31.293Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: AlgoRevise는 React 기반 프론트엔드와 Spring Boot 기반 백엔드를 사용하여 AI 기반 알고리즘 오답 관리 플랫폼을 구축합니다. 사용자가 업로드한 알고리즘 문제의 풀이 흐름을 AI가 분석하고 시각화하며, 사용자는 약점 구간을 선택하여 AI 챗봇의 심층 분석 및 맞춤형 테스트 문제를 제공받습니다. Spring Security를 통해 보안을 강화하고, Spring Data JPA를 사용하여 데이터베이스와 효율적으로 상호 작용합니다. Firebase Storage를 사용하여 문제와 관련된 파일들을 저장하고, Lemon Squeezy를 통해 구독 및 결제 기능을 구현합니다.\n- **핵심 기술 스택**: React, TypeScript, Spring Boot, Spring Security, Spring Data JPA, MySQL, Firebase Storage, Lemon Squeezy\n- **주요 기술 목표**:\n    -   빠른 응답 속도와 안정적인 서비스 제공\n    -   확장 가능한 아키텍처 설계\n    -   높은 수준의 보안 유지\n- **주요 기술 가정**:\n    -   AI 분석 모델의 정확도가 80% 이상을 유지할 수 있다고 가정합니다.\n    -   사용자 트래픽이 예측 가능하며, 필요시 확장 가능하도록 설계합니다.\n    -   외부 API(Lemon Squeezy, Firebase)의 안정적인 작동을 가정합니다.\n\n## 2. 기술 스택\n\n| 범주                | 기술 / 라이브러리           | 이유                                                                                  |\n| ------------------- | --------------------------- | ------------------------------------------------------------------------------------- |\n| 프론트엔드            | React                      | 컴포넌트 기반의 UI 개발에 용이하며, TypeScript와 함께 사용하여 안정성과 개발 효율성을 높입니다. |\n| UI 프레임워크         | TypeScript                 | React와 함께 사용하여 코드의 안정성을 높이고, 대규모 프로젝트 관리에 용이합니다.          |\n| 백엔드                | Spring Boot                | Java 기반의 엔터프라이즈 애플리케이션 개발에 최적화되어 있으며, 빠른 개발과 배포를 지원합니다.   |\n| 보안                  | Spring Security            | 강력한 인증 및 권한 부여 기능을 제공하여 애플리케이션의 보안을 강화합니다.                |\n| 데이터베이스 액세스     | Spring Data JPA           | 데이터베이스와의 상호 작용을 단순화하고, ORM을 통해 객체와 데이터베이스 간의 매핑을 쉽게 관리합니다.   |\n| 데이터베이스            | MySQL                      | 안정적이고 널리 사용되는 오픈 소스 관계형 데이터베이스입니다.                             |\n| 파일 스토리지         | Firebase Storage           | 이미지, 비디오, 오디오 및 기타 사용자 생성 콘텐츠와 같은 파일을 저장하고 제공하는 데 사용됩니다. |\n| 결제                  | Lemon Squeezy              | 구독, 라이선스 및 일회성 결제에 대한 안전하고 사용하기 쉬운 결제 솔루션입니다.               |\n| AI 분석               | (미정, Python + TensorFlow/PyTorch) | 알고리즘 문제 분석 및 맞춤 문제 출제를 위한 머신러닝 모델 구현에 사용합니다. (별도 서버로 분리 가능) |\n| API                   | RESTful API                | 프론트엔드와 백엔드 간의 통신을 위한 표준 인터페이스입니다.                              |\n| 빌드 도구             | Webpack/Vite               | 프론트엔드 자산 번들링 및 최적화를 위해 사용합니다.                                     |\n| CI/CD               | Jenkins/GitHub Actions     | 코드 변경 사항을 자동으로 테스트하고 배포하여 개발 프로세스를 간소화합니다.                 |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **프론트엔드 (React)**: 사용자 인터페이스를 제공하고 사용자 입력을 처리합니다.\n    -   컴포넌트: 문제 등록 폼, 풀이 흐름 시각화, 챗봇 인터페이스, 맞춤 문제 풀이 환경, 학습 통계 대시보드\n    -   상태 관리: Redux 또는 Context API를 사용하여 애플리케이션 상태를 관리합니다.\n- **백엔드 (Spring Boot)**: API 엔드포인트를 제공하고 비즈니스 로직을 처리하며 데이터베이스와 상호 작용합니다.\n    -   API 컨트롤러: 문제 등록, AI 분석 요청, 챗봇 질의, 맞춤 문제 요청, 결제 처리 등을 위한 API 제공\n    -   서비스 레이어: 비즈니스 로직 구현 (AI 분석 연동, 맞춤 문제 생성, 사용자 관리, 결제 처리)\n    -   데이터 액세스 레이어: Spring Data JPA를 사용하여 데이터베이스와 상호 작용\n- **AI 분석 서버**: 알고리즘 문제 분석 및 맞춤 문제 생성을 담당합니다.\n    -   모델 로딩 및 추론: TensorFlow/PyTorch 모델을 로드하고 추론을 수행합니다.\n    -   문제 분석 로직: 문제의 코드 흐름을 분석하고 약점을 식별합니다.\n    -   맞춤 문제 생성 로직: 사용자 약점에 맞는 새로운 문제를 생성합니다.\n- **데이터베이스 (MySQL)**: 사용자 정보, 문제 정보, 풀이 기록, 결제 정보 등을 저장합니다.\n    -   스키마 설계: 사용자, 문제, 풀이, 결제 테이블 설계\n    -   데이터 액세스 최적화: 쿼리 최적화 및 인덱싱\n- **파일 스토리지 (Firebase Storage)**: 사용자가 업로드한 코드 파일 및 기타 관련 파일을 저장합니다.\n    -   파일 업로드 API: 사용자가 파일을 업로드할 수 있는 API 제공\n    -   파일 접근 권한 관리: 사용자별 파일 접근 권한 설정\n\n### 최상위 컴포넌트 상호 작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (React)] --> B(Backend (Spring Boot))\n    B --> C{Database (MySQL)}\n    B --> D[AI 분석 서버]\n    B --> E[Firebase Storage]\n    B --> F[Lemon Squeezy]\n```\n\n-   **Frontend (React) -> Backend (Spring Boot)**: 프론트엔드는 API 요청을 통해 백엔드와 통신합니다. 문제 등록, AI 분석 요청, 챗봇 질의, 맞춤 문제 요청, 결제 처리 등의 작업을 수행합니다.\n-   **Backend (Spring Boot) -> Database (MySQL)**: 백엔드는 Spring Data JPA를 통해 데이터베이스와 상호 작용합니다. 사용자 정보, 문제 정보, 풀이 기록, 결제 정보 등을 저장하고 조회합니다.\n-   **Backend (Spring Boot) -> AI 분석 서버**: 백엔드는 AI 분석 서버에 문제 분석 및 맞춤 문제 생성을 요청합니다.\n-   **Backend (Spring Boot) -> Firebase Storage**: 백엔드는 Firebase Storage에 사용자가 업로드한 코드 파일 및 기타 관련 파일을 저장하고 접근합니다.\n-   **Backend (Spring Boot) -> Lemon Squeezy**: 백엔드는 Lemon Squeezy API를 통해 구독 및 결제 처리를 수행합니다.\n\n### 코드 구성 및 규칙\n\n**도메인 기반 조직 전략**\n- **도메인 분리**: 사용자 관리, 문제 관리, AI 분석, 결제 처리 등 비즈니스 도메인별로 코드를 분리합니다.\n- **계층 기반 아키텍처**: 프레젠테이션 (React 컴포넌트), 비즈니스 로직 (Spring 서비스), 데이터 액세스 (Spring Data JPA 레포지토리), 인프라 (외부 API 연동) 계층으로 분리합니다.\n- **기능 기반 모듈**: 사용자 인증, 문제 등록, AI 분석, 결제 처리 등 관련 기능을 함께 그룹화합니다.\n- **공유 컴포넌트**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 전용 공유 모듈에 배치합니다.\n\n**범용 파일 및 폴더 구조**\n\n```\n/\n├── frontend/                      # React 프론트엔드 코드\n│   ├── src/\n│   │   ├── components/          # 재사용 가능한 UI 컴포넌트\n│   │   ├── pages/               # 각 페이지별 컴포넌트\n│   │   ├── services/            # API 호출 및 데이터 처리\n│   │   ├── utils/               # 유틸리티 함수\n│   │   ├── App.tsx              # 메인 애플리케이션 컴포넌트\n│   │   └── index.tsx            # 애플리케이션 진입점\n│   ├── public/                # 정적 자원 (이미지, 폰트 등)\n│   └── package.json           # npm 패키지 설정\n├── backend/                       # Spring Boot 백엔드 코드\n│   ├── src/\n│   │   ├── main/\n│   │   │   ├── java/\n│   │   │   │   ├── com/example/algorevise/\n│   │   │   │   │   ├── controller/   # API 컨트롤러\n│   │   │   │   │   ├── service/      # 비즈니스 로직 서비스\n│   │   │   │   │   ├── repository/   # Spring Data JPA 레포지토리\n│   │   │   │   │   ├── model/        # 데이터 모델 (Entity)\n│   │   │   │   │   ├── config/       # 설정 파일\n│   │   │   │   │   └── dto/          # 데이터 전송 객체 (DTO)\n│   │   │   ├── resources/     # 설정 파일 (application.properties, application.yml)\n│   │   └── test/              # 테스트 코드\n│   ├── pom.xml                # Maven 프로젝트 설정\n├── ai-analysis-server/          # AI 분석 서버 코드 (별도 레포지토리로 분리 가능)\n│   ├── src/\n│   │   ├── models/             # 머신러닝 모델\n│   │   ├── utils/              # 유틸리티 함수\n│   │   ├── main.py             # 서버 진입점\n│   ├── requirements.txt       # Python 패키지 목록\n├── database/                    # 데이터베이스 스크립트 및 설정\n│   └── schema.sql             # 데이터베이스 스키마 정의\n├── .env                         # 환경 변수 파일\n├── README.md                    # 프로젝트 설명 및 설정 방법\n└── LICENSE                      # 라이선스 정보\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: 프론트엔드는 RESTful API를 통해 백엔드와 통신합니다. API 요청/응답 패턴을 사용합니다.\n- **데이터베이스 상호 작용**: Spring Data JPA를 사용하여 데이터베이스와 상호 작용합니다. ORM을 통해 객체와 데이터베이스 간의 매핑을 관리합니다.\n- **외부 서비스 통합**: Lemon Squeezy API, Firebase Storage API를 사용하여 외부 서비스와 통합합니다. API 키 및 인증 정보를 안전하게 관리합니다.\n- **실시간 통신**: 필요에 따라 WebSocket 또는 SSE (Server-Sent Events)를 사용하여 실시간 업데이트를 제공할 수 있습니다. (예: 챗봇 메시지 전송)\n- **데이터 동기화**: 분산된 컴포넌트 간의 데이터 일관성을 유지하기 위해 트랜잭션 관리 및 데이터 동기화 전략을 적용합니다.\n\n## 4. 성능 및 최적화 전략\n\n- **데이터베이스 쿼리 최적화**: 쿼리 성능 분석 도구를 사용하여 느린 쿼리를 식별하고 인덱싱 및 쿼리 재작성을 통해 최적화합니다.\n- **캐싱**: 자주 액세스하는 데이터를 캐싱하여 데이터베이스 부하를 줄이고 응답 시간을 단축합니다. (예: Redis)\n- **코드 최적화**: 불필요한 연산을 제거하고 알고리즘 효율성을 개선하여 코드 실행 속도를 높입니다.\n- **로드 밸런싱**: 트래픽이 증가할 경우 로드 밸런서를 사용하여 여러 서버에 트래픽을 분산시켜 시스템 부하를 줄입니다.\n- **CDN (콘텐츠 전송 네트워크)**: 정적 자산 (이미지, CSS, JavaScript 파일)을 CDN에 배포하여 사용자에게 더 빠르게 제공합니다.\n- **AI 모델 최적화**: AI 분석 모델의 추론 속도를 높이기 위해 모델 경량화, 양자화, GPU 가속 등의 기술을 적용합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 (MVP 구현)\n- **핵심 인프라**: 기본 시스템 설정 및 필수 구성 요소 구축 (React, Spring Boot, MySQL, Firebase Storage, Lemon Squeezy 연동)\n- **필수 기능**: 문제 등록, AI 분석, 약점 선택 UI, 챗봇 심층 분석, 맞춤 문제 자동 출제 및 채점, 기본 통계 구현\n- **기본 보안**: Spring Security를 사용한 인증 및 권한 부여 구현\n- **개발 환경**: 개발 환경 설정 및 CI/CD 기본 설정\n- **예상 완료 기간**: 3개월\n\n### 2단계: 기능 개선\n- **고급 기능**: 프리미엄 기능 (무제한 맞춤 문제, 고급 통계, 레벨·뱃지, 복습 캘린더 연동) 구현\n- **성능 최적화**: 시스템 성능 개선 (데이터베이스 쿼리 최적화, 캐싱, 코드 최적화)\n- **보안 강화**: 고급 보안 기능 구현 (취약점 분석 및 패치, 보안 감사)\n- **모니터링 구현**: 시스템 모니터링 설정 및 로그 분석\n- **예상 완료 기간**: 3개월\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술적 위험 분석\n- **기술 위험**: AI 분석 정확도 부족, 맞춤 문제 생성의 저작권 문제, 외부 API 의존성\n- **성능 위험**: 트래픽 증가에 따른 시스템 성능 저하, AI 분석 서버의 응답 시간 지연\n- **보안 위험**: SQL 인젝션, XSS 공격, 데이터 유출\n- **통합 위험**: 외부 API (Lemon Squeezy, Firebase)의 장애 발생\n- **완화 전략**:\n    -   AI 모델 튜닝 및 데이터 증강을 통해 분석 정확도 향상\n    -   자체 생성 문제 사용 및 저작권 검토\n    -   외부 API 장애 대비 대체 API 또는 로컬 캐싱 구현\n    -   로드 밸런싱 및 캐싱을 통해 시스템 성능 유지\n    -   보안 취약점 점검 및 코드 검토, 보안 라이브러리 사용\n\n### 프로젝트 인도 위험\n- **일정 위험**: 개발 일정 지연, 외부 API 변경\n- **자원 위험**: 팀 역량 부족, AI 엔지니어 부족\n- **품질 위험**: 코드 품질 저하, 테스트 부족\n- **배포 위험**: 배포 환경 문제, 롤백 실패\n- **비상 계획**:\n    -   일정 지연 시 기능 축소 또는 추가 인력 투입\n    -   팀 역량 강화를 위한 교육 및 외부 전문가 자문\n    -   코드 리뷰 및 자동화된 테스트 강화\n    -   배포 전 철저한 테스트 및 롤백 계획 수립\n",
      "writedAt": "2025-09-13T01:31:31.294Z"
    },
    {
      "type": "guideline",
      "content": "# AlgoRevise Code Guideline\n\n## 1. Project Overview\n\nAlgoRevise is an AI-powered algorithm problem management platform built using React for the frontend and Spring Boot for the backend. The platform provides AI analysis and visualization of problem-solving logic, AI chatbot support for identifying weaknesses, and custom test problem generation. Key architectural decisions include a component-based React frontend, a RESTful API for communication, a layered Spring Boot backend, and the use of Spring Data JPA for database interaction.\n\n## 2. Core Principles\n\n*   **Maintainability**: Code should be easy to understand, modify, and debug.\n*   **Testability**: Code should be designed to facilitate unit and integration testing.\n*   **Readability**: Code should be clear, concise, and well-documented.\n*   **Performance**: Code should be efficient and optimized for speed and resource usage.\n*   **Security**: Code should be written with security in mind, preventing common vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. React (Frontend)\n\n*   **File Organization**:\n    *   Components: `src/components/` (Reusable UI elements)\n    *   Pages: `src/pages/` (Route-specific components)\n    *   Services: `src/services/` (API interaction logic)\n    *   Utils: `src/utils/` (Utility functions)\n    *   Types: `src/types/` (Global Type definitions)\n*   **Import/Dependency Management**:\n    *   Use absolute imports (`src/`) for internal modules.\n    *   Declare dependencies in `package.json` and use `npm` or `yarn`.\n*   **Error Handling**:\n    *   Use `try...catch` blocks for handling API errors.\n    *   Implement error boundary components for catching rendering errors.\n\n### 3.2. Spring Boot (Backend)\n\n*   **File Organization**:\n    *   Controllers: `src/main/java/com/example/algorevise/controller/` (REST API endpoints)\n    *   Services: `src/main/java/com/example/algorevise/service/` (Business logic)\n    *   Repositories: `src/main/java/com/example/algorevise/repository/` (Data access)\n    *   Models: `src/main/java/com/example/algorevise/model/` (Entities)\n    *   DTOs: `src/main/java/com/example/algorevise/dto/` (Data Transfer Objects)\n    *   Config: `src/main/java/com/example/algorevise/config/` (Configuration files)\n*   **Import/Dependency Management**:\n    *   Use Maven (`pom.xml`) for dependency management.\n    *   Organize dependencies into logical groups.\n*   **Error Handling**:\n    *   Use `@ControllerAdvice` for global exception handling.\n    *   Return appropriate HTTP status codes and error messages in API responses.\n\n### 3.3. Python (AI Analysis Server - if applicable)\n\n*   **File Organization**:\n    *   Models: `src/models/` (Machine learning models)\n    *   Utils: `src/utils/` (Utility functions)\n    *   Main script: `src/main.py` (Server entry point)\n*   **Import/Dependency Management**:\n    *   Use `requirements.txt` for dependency management.\n    *   Use virtual environments (`venv`) to isolate dependencies.\n*   **Error Handling**:\n    *   Use `try...except` blocks to handle exceptions.\n    *   Implement logging for debugging and monitoring.\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow:\n\n#### 4.1.1. React (Frontend)\n\n*   **Functional Components**: Use functional components with hooks for state management and side effects.\n    *   Rationale: Promotes code reusability, testability, and readability.\n    ```typescript\n    // MUST: Functional Component with Hooks\n    import React, { useState } from 'react';\n\n    const MyComponent: React.FC = () => {\n      const [count, setCount] = useState(0);\n\n      return (\n        <div>\n          <p>Count: {count}</p>\n          <button onClick={() => setCount(count + 1)}>Increment</button>\n        </div>\n      );\n    };\n    ```\n*   **TypeScript**: Use TypeScript for type safety and improved code maintainability.\n    *   Rationale: Prevents runtime errors and facilitates code refactoring.\n    ```typescript\n    // MUST: TypeScript interface\n    interface User {\n      id: number;\n      name: string;\n      email: string;\n    }\n\n    const greetUser = (user: User) => {\n      console.log(`Hello, ${user.name}!`);\n    };\n    ```\n*   **Consistent Naming**: Use consistent naming conventions for variables, functions, and components (e.g., `camelCase` for variables and functions, `PascalCase` for components).\n    *   Rationale: Improves code readability and maintainability.\n*   **Immutability**: Treat state as immutable and use appropriate methods to update it (e.g., spread operator).\n    *   Rationale: Prevents unexpected side effects and simplifies state management.\n    ```typescript\n    // MUST: Immutable state update\n    const updateArray = (index: number, newValue: any) => {\n      setMyArray(prevArray => [\n        ...prevArray.slice(0, index),\n        newValue,\n        ...prevArray.slice(index + 1)\n      ]);\n    };\n    ```\n\n#### 4.1.2. Spring Boot (Backend)\n\n*   **Layered Architecture**: Adhere to a layered architecture (Controller, Service, Repository) for separation of concerns.\n    *   Rationale: Improves code organization, testability, and maintainability.\n*   **Dependency Injection**: Use dependency injection to manage dependencies between components.\n    *   Rationale: Promotes loose coupling and testability.\n    ```java\n    // MUST: Dependency Injection\n    @Service\n    public class UserService {\n\n      private final UserRepository userRepository;\n\n      @Autowired\n      public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n      }\n\n      // ...\n    }\n    ```\n*   **RESTful API Design**: Follow RESTful principles for API design (e.g., use appropriate HTTP methods, status codes, and resource naming).\n    *   Rationale: Ensures consistency and interoperability.\n*   **Spring Data JPA**: Utilize Spring Data JPA for database interactions.\n    *   Rationale: Simplifies data access and reduces boilerplate code.\n    ```java\n    // MUST: Spring Data JPA Repository\n    import org.springframework.data.jpa.repository.JpaRepository;\n    import com.example.algorevise.model.User;\n\n    public interface UserRepository extends JpaRepository<User, Long> {\n      // Custom query methods can be defined here\n    }\n    ```\n*   **DTOs**: Use Data Transfer Objects (DTOs) for transferring data between layers.\n    *   Rationale: Decouples data models from API contracts and allows for data transformation.\n*   **Logging**: Use a logging framework (e.g., SLF4J) for logging application events.\n    *   Rationale: Facilitates debugging, monitoring, and auditing.\n\n#### 4.1.3. General\n\n*   **Code Comments**: Write clear and concise comments to explain complex logic or non-obvious code.\n    *   Rationale: Improves code understanding and maintainability.\n*   **Unit Tests**: Write unit tests for all critical components and functions.\n    *   Rationale: Ensures code quality and prevents regressions.\n*   **Error Handling**: Implement robust error handling to prevent application crashes and provide informative error messages.\n    *   Rationale: Improves application stability and user experience.\n\n### 4.2. MUST NOT Do:\n\n#### 4.2.1. React (Frontend)\n\n*   **Direct DOM Manipulation**: Avoid direct DOM manipulation using `document.getElementById` or similar methods. Use React's virtual DOM instead.\n    *   Rationale: Can lead to performance issues and inconsistencies.\n    ```typescript\n    // MUST NOT: Direct DOM manipulation\n    // document.getElementById('myElement').innerHTML = 'Hello!';\n\n    // MUST: Use React's state and rendering\n    const [text, setText] = useState('Hello!');\n    // ...\n    <div id=\"myElement\">{text}</div>\n    ```\n*   **Mutating State Directly**: Do not directly mutate the state object. Use `setState` or the hook equivalent to trigger re-renders.\n    *   Rationale: Direct mutation can lead to unexpected behavior and prevent React from properly updating the UI.\n    ```typescript\n    // MUST NOT: Direct state mutation\n    // this.state.count = 5; // Incorrect\n\n    // MUST: Use setState or useState hook\n    setCount(5); // Correct\n    ```\n*   **Ignoring Linter Warnings**: Do not ignore linter warnings or errors. Address them promptly to maintain code quality.\n    *   Rationale: Linters help identify potential issues and enforce coding standards.\n\n#### 4.2.2. Spring Boot (Backend)\n\n*   **Catching Generic Exceptions**: Avoid catching generic `Exception` without specific handling.\n    *   Rationale: Can hide underlying issues and make debugging difficult.\n    ```java\n    // MUST NOT: Catching generic Exception\n    // try {\n    //   // ...\n    // } catch (Exception e) {\n    //   // ...\n    // }\n\n    // MUST: Catch specific exceptions\n    try {\n      // ...\n    } catch (SQLException e) {\n      // Handle database-related errors\n    } catch (IOException e) {\n      // Handle file-related errors\n    }\n    ```\n*   **Ignoring Exceptions**: Never ignore exceptions without logging or handling them.\n    *   Rationale: Can lead to hidden errors and application instability.\n*   **Writing Complex Logic in Controllers**: Avoid writing complex business logic directly in controllers. Move it to the service layer.\n    *   Rationale: Keeps controllers clean and promotes separation of concerns.\n*   **Hardcoding Configuration**: Avoid hardcoding configuration values (e.g., database URLs, API keys). Use environment variables or configuration files.\n    *   Rationale: Improves application portability and security.\n\n#### 4.2.3. General\n\n*   **Long Methods/Functions**: Avoid writing long methods or functions that perform multiple tasks. Break them down into smaller, more manageable units.\n    *   Rationale: Improves code readability and testability.\n*   **Magic Numbers/Strings**: Avoid using magic numbers or strings directly in the code. Define them as constants with meaningful names.\n    *   Rationale: Improves code readability and maintainability.\n    ```java\n    // MUST NOT: Magic number\n    // if (user.getAge() > 18) { ... }\n\n    // MUST: Constant\n    private static final int ADULT_AGE = 18;\n    if (user.getAge() > ADULT_AGE) { ... }\n    ```\n*   **Nested Conditional Statements**: Avoid deeply nested conditional statements. Use guard clauses or other techniques to simplify the logic.\n    *   Rationale: Improves code readability and reduces complexity.\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n*   **Frontend (React)**:\n    *   **Atomic Design**: Consider using Atomic Design principles to structure components (Atoms, Molecules, Organisms, Templates, Pages).\n    *   **Container/Presentational Components**: Separate container components (which handle data fetching and state management) from presentational components (which focus on rendering UI).\n*   **Backend (Spring Boot)**:\n    *   **Domain-Driven Design (DDD)**: Apply DDD principles to structure the backend code around business domains.\n    *   **Microservices**: Consider using a microservices architecture for scalability and maintainability (if the application becomes very large and complex).\n\n### 5.2. Data Flow Patterns\n\n*   **Unidirectional Data Flow (React)**: Follow the unidirectional data flow pattern in React, where data flows from parent to child components.\n*   **RESTful API (Frontend/Backend)**: Use RESTful APIs for communication between the frontend and backend.\n*   **Event-Driven Architecture (Backend)**: Consider using an event-driven architecture for asynchronous communication between services.\n\n### 5.3. State Management Conventions (React)\n\n*   **Context API**: Use React's Context API for managing global state that is accessed by many components.\n*   **Redux (Optional)**: Consider using Redux for more complex state management scenarios, especially when dealing with asynchronous actions and data persistence.\n*   **Centralized Store**: Store the application state in a centralized store for predictable state management.\n\n### 5.4. API Design Standards\n\n*   **RESTful Principles**: Adhere to RESTful principles for API design.\n*   **Consistent Naming**: Use consistent naming conventions for API endpoints and request/response parameters.\n*   **Versioning**: Use API versioning to maintain backward compatibility.\n*   **Authentication/Authorization**: Implement proper authentication and authorization mechanisms to secure API endpoints.\n*   **Error Handling**: Return informative error messages and appropriate HTTP status codes for API errors.\n*   **Data Validation**: Validate all incoming data to prevent invalid data from being processed.\n    *   Rationale: Prevents security vulnerabilities and ensures data integrity.\n*   **Input Sanitization**: Sanitize all user inputs to prevent XSS and other injection attacks.\n    *   Rationale: Improves application security.\n```java\n    // MUST: Validate input\n    @PostMapping(\"/problems\")\n    public ResponseEntity<?> createProblem(@Valid @RequestBody ProblemDTO problemDTO, BindingResult bindingResult) {\n        if (bindingResult.hasErrors()) {\n            return ResponseEntity.badRequest().body(bindingResult.getAllErrors());\n        }\n        // ...\n    }\n```\n```typescript\n// MUST: Validate input\nfunction validateEmail(email: string): boolean {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n```\n",
      "writedAt": "2025-09-13T01:31:31.294Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-13T01:31:31.294Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-13T01:31:31.294Z"
    }
  ]
}